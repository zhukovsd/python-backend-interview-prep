[category]
  id = 1
  title = "ООП"
  popularity = 100.0

[[questions]]
  id = 1
  question = "Что такое ООП?"
  answer = "ООП - методология программирования, центральное место в которой занимает объект. Программа же в целом - совокупность объектов (экземпляров классов). Класс в свою очередь представляет собой шаблон и состоит из:\n\n- Полей\n- Конструктора\n- Методов"
  popularity = 100.0

[[questions]]
  id = 2
  question = "Плюсы и минусы ООП"
  answer = "Плюсы:\n\n- Делим программу на «модули»-классы, ОБЪЕКТЫ каждый из которых делает свою часть работы.\n- Код можно повторно использовать в любом месте программы, это экономит время (не нужно писать однотипные функции для разных сущностей).\n- «Более естественная» декомпозиция ПО существенно облегчает его разработку (код легко читается и быстро пишется).\n- Возможность создавать расширяемые системы (extensible systems), именно это отличает ООП от традиционных методов программирования.\n\nМинусы:\n\n- Снижение производительности, увеличение потребности памяти (Информация распределяется на множество мелких инкапсулированных объектов ⇒ на них растет количество ссылок)"
  popularity = 100.0

[[questions]]
  id = 3
  question = "Принципы ООП (наследование, инкапсуляция, полиморфизм, абстракция)"
  answer = "**Инкапсуляция** - объединение данных и методов, работающих с ними в одном классе, а так же сокрытие деталей реализации от пользователя. В Python инкапсуляция реализуется через соглашения об именовании (один подчеркивание `_` для защищенных членов, два подчеркивания `__` для приватных) и свойства (property декораторы).\n\n**Наследование** - возможность порождать один класс от другого (родительского) с сохранением всех его свойств и методов, добавляя при необходимости новые свойства и методы. Python поддерживает множественное наследование.\n\n**Полиморфизм** - это способность объектов одного типа вести себя как объекты других типов (обычно подклассов или классов, реализующих общий интерфейс), что позволяет вызывать один и тот же метод через общий интерфейс, а реализация будет определяться во время выполнения программы\n\n- **Динамическим** (duck typing, переопределение методов)\n  - Достигается переопределением методов в подклассах\n  - Решение, какую версию метода вызвать, принимается во время выполнения программы\n  - В Python используется принцип \"утиной типизации\" - важен не тип объекта, а наличие у него нужного метода\n\n```python\nclass Animal:\n    def sound(self):\n        print(\"Some generic animal sound\")\n\nclass Dog(Animal):\n    def sound(self):  # Переопределение метода\n        print(\"Woof!\")\n\nclass Cat(Animal):\n    def sound(self):  # Переопределение метода\n        print(\"Meow!\")\n\n# Демонстрация\ndef make_sound(animal):\n    animal.sound()  # Полиморфный вызов\n\na1 = Dog()\na2 = Cat()\n\nmake_sound(a1)  # Woof!\nmake_sound(a2)  # Meow!\n\n# Утиная типизация - даже не обязательно наследоваться от Animal\nclass Car:\n    def sound(self):\n        print(\"Vroom!\")\n\nmake_sound(Car())  # Vroom!\n```\n\nПеременная может ссылаться на объект Dog, Cat или даже Car, а метод sound() будет вызван в соответствии с реальным типом объекта в рантайме.\n\n- **Статическим** (перегрузка функций)\n  - В Python отсутствует традиционная перегрузка методов как в Java\n  - Достигается через параметры по умолчанию, `*args`, `**kwargs` или с помощью декораторов (например, `@singledispatch`)\n\n```python\nfrom functools import singledispatch\n\n# Способ 1: Параметры по умолчанию\nclass MathUtils:\n    def add(self, a, b, c=None):\n        if c is not None:\n            return a + b + c\n        return a + b\n\n# Способ 2: singledispatch для перегрузки по типам\n@singledispatch\ndef process(value):\n    return f\"Обработка значения: {value}\"\n\n@process.register(int)\ndef _(value):\n    return f\"Обработка целого числа: {value}\"\n\n@process.register(str)\ndef _(value):\n    return f\"Обработка строки: {value}\"\n\n@process.register(list)\ndef _(value):\n    return f\"Обработка списка из {len(value)} элементов\"\n\n# Демонстрация\nutils = MathUtils()\nprint(utils.add(2, 3))        # 5\nprint(utils.add(2, 3, 4))      # 9\n\nprint(process(42))             # Обработка целого числа: 42\nprint(process(\"hello\"))        # Обработка строки: hello\nprint(process([1, 2, 3]))      # Обработка списка из 3 элементов\n```\n\nЗдесь метод add имеет одно имя, но может принимать разное количество аргументов благодаря параметру по умолчанию, а декоратор `@singledispatch` позволяет выбрать реализацию на основе типа аргумента.\n\n**Абстракция** – это способ выделить набор общих характеристик объекта, исключая из рассмотрения частные и незначимые. Соответственно, абстракция – это набор всех таких характеристик. В Python абстракция реализуется через абстрактные базовые классы (ABC) из модуля `abc`.\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):  # Абстрактный класс\n    @abstractmethod\n    def area(self):\n        \"\"\"Абстрактный метод - должен быть реализован в подклассах\"\"\"\n        pass\n    \n    @abstractmethod\n    def perimeter(self):\n        \"\"\"Абстрактный метод\"\"\"\n        pass\n    \n    def description(self):  # Обычный метод\n        return f\"Это фигура с площадью {self.area()}\"\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):  # Реализация абстрактного метода\n        return self.width * self.height\n    \n    def perimeter(self):  # Реализация абстрактного метода\n        return 2 * (self.width + self.height)\n\n# Использование\nrect = Rectangle(5, 3)\nprint(rect.area())        # 15\nprint(rect.perimeter())   # 16\nprint(rect.description()) # Это фигура с площадью 15\n```"
  popularity = 0.0

[[questions]]
  id = 4
  question = "Класс, объект, интерфейс"
  answer = "**Класс** – это описание ещё не созданного объекта, общий шаблон.\nШаблон состоит из:\n   - **Атрибутов (полей)** – переменных, принадлежащих объекту (имя, возраст для человека и т.д.). Определяют состояние объекта.\n   - **Конструктора (`__init__`)** – специального метода, который автоматически вызывается при создании объекта и инициализирует его начальное состояние.\n   - **Методов** – функций, принадлежащих классу, которые определяют поведение объекта (что он умеет делать).\n\n```python\nclass Person:\n    # Конструктор - инициализация объекта\n    def __init__(self, name, age):\n        # Атрибуты (поля) объекта\n        self.name = name\n        self.age = age\n    \n    # Метод класса\n    def introduce(self):\n        return f\"Привет, меня зовут {self.name}, мне {self.age} лет\"\n    \n    # Ещё один метод\n    def have_birthday(self):\n        self.age += 1\n        print(f\"С днём рождения! Теперь {self.name} {self.age} лет\")\n```\n\n**Объект** – это экземпляр класса, созданный по шаблону с собственным состоянием атрибутов.\n\n```python\n# Создание объектов (экземпляров класса)\nperson1 = Person(\"Анна\", 25)  # Вызов конструктора\nperson2 = Person(\"Иван\", 30)\n\n# Каждый объект имеет своё состояние\nprint(person1.name)  # Анна\nprint(person2.name)  # Иван\n\n# Вызов методов объектов\nprint(person1.introduce())  # Привет, меня зовут Анна, мне 25 лет\nperson2.have_birthday()     # С днём рождения! Теперь Иван 31 лет\n```\n\n**Интерфейс** — в Python нет строгого понятия интерфейса как в Java, но аналогичная функциональность достигается через:\n- **Абстрактные базовые классы (ABC)** – определяют контракт (набор методов), который должен реализовать любой класс-наследник\n- **Протоколы (Protocol)** – неформальные интерфейсы, основанные на утиной типизации (начиная с Python 3.8)\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Protocol\n\n# Способ 1: Абстрактный базовый класс (формальный интерфейс)\nclass Drawable(ABC):\n    @abstractmethod\n    def draw(self):\n        \"\"\"Абстрактный метод - должен быть реализован\"\"\"\n        pass\n    \n    @abstractmethod\n    def get_size(self):\n        \"\"\"Ещё один обязательный метод\"\"\"\n        pass\n\n# Класс, реализующий интерфейс Drawable\nclass Circle(Drawable):\n    def __init__(self, radius):\n        self.radius = radius\n    \n    def draw(self):  # Обязательная реализация\n        print(f\"Рисуем круг радиусом {self.radius}\")\n    \n    def get_size(self):  # Обязательная реализация\n        return f\"Площадь круга: {3.14 * self.radius ** 2}\"\n\n# Способ 2: Протокол (утиная типизация)\nclass Flyable(Protocol):\n    def fly(self) -> str:\n        \"\"\"Контракт: любой объект с методом fly() считается Flyable\"\"\"\n        ...\n\nclass Bird:\n    def fly(self):\n        return \"Птица летит\"\n\nclass Airplane:\n    def fly(self):\n        return \"Самолет летит\"\n    \n    def refuel(self):\n        print(\"Заправка\")\n\n# Функция, работающая с любым объектом, реализующим протокол Flyable\ndef make_it_fly(flying_obj: Flyable):\n    print(flying_obj.fly())\n\n# Использование\ncircle = Circle(5)\ncircle.draw()           # Рисуем круг радиусом 5\nprint(circle.get_size()) # Площадь круга: 78.5\n\nbird = Bird()\nplane = Airplane()\n\nmake_it_fly(bird)  # Птица летит\nmake_it_fly(plane) # Самолет летит - работает, даже если класс не наследует Flyable\n```\n\nИнтерфейсы позволяют задавать общие действия, которые могут выполнять различные классы, не завися от их конкретной реализации. В Python это достигается как через явное наследование от ABC, так и через неявные протоколы (утиную типизацию)."
  popularity = 0.0

[[questions]]
  id = 5
  question = "Ассоциация, агрегация, композиция"
  answer = "**Ассоциация** означает, что объекты двух классов могут ссылаться один на другой, иметь связь друг с другом. Один класс включает в себя другой класс в качестве одного из полей (атрибутов).\n\n```python\nclass Student:\n    def __init__(self, name):\n        self.name = name\n        self.courses = []  # Ассоциация: студент связан с курсами\n    \n    def enroll(self, course):\n        self.courses.append(course)\n        course.add_student(self)  # Двунаправленная связь\n\nclass Course:\n    def __init__(self, title):\n        self.title = title\n        self.students = []  # Ассоциация: курс связан со студентами\n    \n    def add_student(self, student):\n        self.students.append(student)\n\n# Использование\nstudent = Student(\"Анна\")\ncourse = Course(\"Python\")\n\nstudent.enroll(course)  # Устанавливаем связь между объектами\nprint(f\"{student.name} записана на {course.title}\")\nprint(f\"На курс {course.title} записано {len(course.students)} студентов\")\n```\n\n> **Агрегация** и **композиция** являются частными случаями ассоциации. Это более конкретизированные отношения между объектами, описывающие жизненный цикл и владение объектами.\n\n**Композиция** — это более жёсткое отношение, когда объект не только является частью другого объекта, но и вообще не может принадлежать кому-то другому. Время жизни части полностью управляется целым (если целое уничтожается, части тоже уничтожаются).\n\n```python\nclass Page:\n    def __init__(self, number, content):\n        self.number = number\n        self.content = content\n    \n    def read(self):\n        return f\"Страница {self.number}: {self.content}\"\n\nclass Book:\n    def __init__(self, title, author):\n        self.title = title\n        self.author = author\n        # Композиция: страницы создаются внутри книги и принадлежат только ей\n        self.pages = [\n            Page(1, \"Введение в Python\"),\n            Page(2, \"Основы синтаксиса\"),\n            Page(3, \"ООП в Python\")\n        ]\n    \n    def read_page(self, page_number):\n        if 1 <= page_number <= len(self.pages):\n            return self.pages[page_number - 1].read()\n        return \"Страница не найдена\"\n    \n    def __del__(self):\n        print(f\"Книга '{self.title}' удаляется, все её страницы тоже удаляются\")\n\n# Использование\nbook = Book(\"Изучаем Python\", \"Иван Петров\")\nprint(book.read_page(1))  # Страница 1: Введение в Python\n\n# При удалении книги страницы тоже \"исчезают\" - они не могут существовать отдельно\ndel book\n# Страницы больше не доступны\n```\n\n**Агрегация** — отношение, когда один объект является частью другого, но при этом может существовать независимо и принадлежать разным объектам в разное время.\n\n```python\nclass Engine:\n    def __init__(self, engine_type, horsepower):\n        self.engine_type = engine_type\n        self.horsepower = horsepower\n        self.car = None  # Ссылка на текущую машину\n    \n    def install_in(self, car):\n        \"\"\"Установить двигатель в машину\"\"\"\n        if self.car:\n            print(f\"Двигатель уже установлен в {self.car.model}\")\n        else:\n            self.car = car\n            print(f\"Двигатель {self.engine_type} установлен в {car.model}\")\n    \n    def remove_from_car(self):\n        \"\"\"Снять двигатель с машины\"\"\"\n        if self.car:\n            print(f\"Двигатель снят с {self.car.model}\")\n            self.car = None\n        else:\n            print(\"Двигатель не установлен\")\n    \n    def __str__(self):\n        return f\"Двигатель {self.engine_type} ({self.horsepower} л.с.)\"\n\nclass Car:\n    def __init__(self, model, color):\n        self.model = model\n        self.color = color\n        self.engine = None  # Агрегация: двигатель может быть, а может и не быть\n    \n    def install_engine(self, engine):\n        \"\"\"Установить двигатель в эту машину\"\"\"\n        if self.engine:\n            print(f\"В машине {self.model} уже есть двигатель\")\n        else:\n            engine.install_in(self)  # Двигатель сам себя устанавливает\n            self.engine = engine\n    \n    def remove_engine(self):\n        \"\"\"Снять двигатель с машины\"\"\"\n        if self.engine:\n            self.engine.remove_from_car()\n            self.engine = None\n        else:\n            print(f\"В машине {self.model} нет двигателя\")\n    \n    def __str__(self):\n        if self.engine:\n            return f\"{self.color} {self.model} с {self.engine}\"\n        else:\n            return f\"{self.color} {self.model} (без двигателя)\"\n\n# Демонстрация агрегации\n# Создаём двигатели - они могут существовать независимо\nv8_engine = Engine(\"V8\", 400)\nelectric_engine = Engine(\"Электрический\", 200)\n\n# Создаём машины\ncar1 = Car(\"Ford Mustang\", \"Красный\")\ncar2 = Car(\"Tesla Model S\", \"Белый\")\n\nprint(\"--- Агрегация: двигатели могут переставляться между машинами ---\")\nprint(v8_engine)  # Двигатель V8 (400 л.с.)\nprint(car1)       # Красный Ford Mustang (без двигателя)\n\n# Устанавливаем двигатель в первую машину\nprint(\"\\n--- Установка двигателя ---\")\ncar1.install_engine(v8_engine)\nprint(car1)  # Красный Ford Mustang с Двигатель V8 (400 л.с.)\n\n# Пытаемся установить тот же двигатель во вторую машину\nprint(\"\\n--- Попытка установить занятый двигатель ---\")\ncar2.install_engine(v8_engine)  # Двигатель уже занят\n\n# Снимаем двигатель с первой машины и ставим во вторую\nprint(\"\\n--- Перестановка двигателя ---\")\ncar1.remove_engine()\ncar2.install_engine(v8_engine)\nprint(car1)  # Красный Ford Mustang (без двигателя)\nprint(car2)  # Белый Tesla Model S с Двигатель V8 (400 л.с.)\n\n# Двигатель продолжает существовать, даже если все машины удалены\nprint(\"\\n--- Двигатель живёт отдельно от машин ---\")\ndel car1\ndel car2\nprint(v8_engine)  # Двигатель V8 (400 л.с.) всё ещё существует\n```\n\n**Ключевые различия в Python:**\n\n1. **Композиция**: объект-часть создаётся внутри конструктора и не может быть передан извне или использован отдельно\n2. **Агрегация**: объект-часть создаётся отдельно и передаётся в конструктор или метод, может переходить от одного объекта к другому\n\n```python\n# Наглядное сравнение\nclass Wheel:\n    def __init__(self, size):\n        self.size = size\n\n# Композиция - колёса создаются вместе с машиной\nclass CarWithComposition:\n    def __init__(self, model):\n        self.model = model\n        # Колёса создаются внутри и привязаны к этой машине\n        self.wheels = [Wheel(17) for _ in range(4)]\n    \n    def __del__(self):\n        print(f\"Машина {self.model} уничтожена, колёса тоже\")\n\n# Агрегация - колёса могут существовать отдельно\nclass CarWithAggregation:\n    def __init__(self, model, wheels):\n        self.model = model\n        self.wheels = wheels  # Колёса приходят извне\n    \n    def __del__(self):\n        print(f\"Машина {self.model} уничтожена, но колёса остались\")\n\n# Демонстрация\nprint(\"=== Композиция ===\")\ncar1 = CarWithComposition(\"BMW\")\ndel car1  # Колёса уничтожаются вместе с машиной\n\nprint(\"\\n=== Агрегация ===\")\nwheels = [Wheel(18) for _ in range(4)]\ncar2 = CarWithAggregation(\"Audi\", wheels)\ndel car2  # Машина уничтожена, но колёса продолжают существовать\nprint(wheels)  # Колёса всё ещё здесь, их можно использовать в другой машине\n```"
  popularity = 0.0

[[questions]]
  id = 6
  question = "Статическое и динамическое связывание"
  answer = "**Связывание (Binding)** — процесс, в ходе которого программа определяет, какой метод или атрибут должен быть вызван или использован. В Python связывание имеет свои особенности, отличные от Java.\n\n## Раннее (статическое) связывание в Python\n\nВ Python раннее связывание происходит во время определения класса или компиляции в байт-код. Применяется для:\n\n- **Атрибутов класса** (переменных уровня класса)\n- **Статических методов** (`@staticmethod`)\n- **Методов класса** (`@classmethod`)\n- **Имен функций и переменных** в области видимости\n\n```python\nclass MathOperations:\n    # Атрибут класса - раннее связывание\n    pi = 3.14159\n    \n    def __init__(self, value):\n        self.value = value  # Атрибут экземпляра - позднее связывание\n    \n    @staticmethod\n    def add(a, b):  # Статический метод - раннее связывание\n        return a + b\n    \n    @classmethod\n    def create_default(cls):  # Метод класса - раннее связывание\n        return cls(0)\n    \n    def multiply(self, factor):  # Обычный метод - позднее связывание\n        return self.value * factor\n\n# Демонстрация раннего связывания\nprint(MathOperations.pi)  # 3.14159 - атрибут класса известен до создания объекта\nprint(MathOperations.add(5, 3))  # 8 - статический метод вызывается без объекта\n\n# Создание объекта через метод класса\nobj = MathOperations.create_default()  # Метод класса связан на этапе определения\nprint(obj.value)  # 0\n```\n\n## Позднее (динамическое) связывание в Python\n\nВ Python позднее связывание происходит во время выполнения программы. Используется для:\n\n- **Методов экземпляра** (обычные методы)\n- **Переопределенных методов** (полиморфизм)\n- **Атрибутов, добавляемых динамически**\n- **Утиной типизации**\n\n```python\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n    \n    def speak(self):  # Будет связано динамически\n        return f\"{self.name} издаёт звук\"\n\nclass Dog(Animal):\n    def speak(self):  # Переопределение - динамическое связывание\n        return f\"{self.name} говорит: Гав!\"\n\nclass Cat(Animal):\n    def speak(self):  # Переопределение - динамическое связывание\n        return f\"{self.name} говорит: Мяу!\"\n\n# Демонстрация динамического связывания\nanimals = [\n    Dog(\"Бобик\"),\n    Cat(\"Мурка\"),\n    Animal(\"Животное\")\n]\n\nfor animal in animals:\n    # Какой метод speak() будет вызван?\n    # Решение принимается ВО ВРЕМЯ ВЫПОЛНЕНИЯ на основе типа объекта\n    print(animal.speak())\n# Вывод:\n# Бобик говорит: Гав!\n# Мурка говорит: Мяу!\n# Животное издаёт звук\n```\n\n## Динамическое связывание атрибутов в Python\n\nУникальная особенность Python - возможность динамически добавлять атрибуты и методы:\n\n```python\nclass DynamicClass:\n    def __init__(self, name):\n        self.name = name  # Обычный атрибут\n\n# Создаем объект\nobj = DynamicClass(\"Объект1\")\n\n# Динамически добавляем новый атрибут (позднее связывание)\nobj.new_attr = \"Я появился во время выполнения!\"\nprint(obj.new_attr)  # Я появился во время выполнения!\n\n# Динамически добавляем метод\ndef new_method(self):\n    return f\"Динамический метод для {self.name}\"\n\n# Привязываем метод к экземпляру\nobj.dynamic_method = new_method.__get__(obj)\nprint(obj.dynamic_method())  # Динамический метод для Объект1\n\n# Добавляем метод к классу (будет доступен всем экземплярам)\nDynamicClass.class_method = lambda self: f\"Метод класса для {self.name}\"\nprint(obj.class_method())  # Метод класса для Объект1\n```\n\n## Связывание в замыканиях и декораторах\n\nПозднее связывание в Python также проявляется в замыканиях:\n\n```python\n# Проблема позднего связывания в замыканиях\nfunctions = []\nfor i in range(3):\n    def func():\n        return i  # i будет связано ПОЗДНЕ, при вызове функции\n    functions.append(func)\n\n# Кажется, что функции должны вернуть 0, 1, 2\nfor f in functions:\n    print(f())  # Выводит: 2, 2, 2 (значение i после завершения цикла)\n\n# Решение - раннее связывание через аргумент по умолчанию\nfunctions_fixed = []\nfor i in range(3):\n    def func(x=i):  # i связывается РАННЕ, в момент определения\n        return x\n    functions_fixed.append(func)\n\nfor f in functions_fixed:\n    print(f())  # Выводит: 0, 1, 2\n```\n\n## Связывание в декораторах и property\n\n```python\nclass Temperature:\n    def __init__(self, celsius):\n        self._celsius = celsius\n    \n    @property  # Дескриптор - позднее связывание при доступе\n    def fahrenheit(self):\n        return (self._celsius * 9/5) + 32\n    \n    @fahrenheit.setter\n    def fahrenheit(self, value):\n        self._celsius = (value - 32) * 5/9\n    \n    @staticmethod\n    def from_fahrenheit(value):  # Статический метод - раннее связывание\n        celsius = (value - 32) * 5/9\n        return Temperature(celsius)\n\n# Использование\nt = Temperature(25)\nprint(t.fahrenheit)  # 77.0 - свойство вычисляется динамически\n\nt.fahrenheit = 100\nprint(t._celsius)  # 37.777... - сеттер сработал динамически\n\n# Статический метод вызван через класс (раннее связывание)\nt2 = Temperature.from_fahrenheit(212)\nprint(t2._celsius)  # 100.0\n```\n\n## Ключевые отличия от Java\n\n| Аспект | Java | Python |\n|--------|------|--------|\n| Раннее связывание | `private`, `final`, `static`, перегруженные методы | Статические методы, методы класса, атрибуты класса |\n| Позднее связывание | Переопределенные методы, абстрактные методы | Все методы экземпляра, переопределенные методы |\n| Динамические атрибуты | Нет возможности | Можно добавлять в любой момент |\n| Перегрузка методов | На этапе компиляции | Не поддерживается (используются args/kwargs) |\n\n```python\n# Практический пример с разными типами связывания\nclass PaymentSystem:\n    tax_rate = 0.2  # Атрибут класса - раннее связывание\n    \n    def __init__(self, amount):\n        self.amount = amount  # Атрибут экземпляра - позднее\n    \n    @classmethod\n    def set_tax_rate(cls, rate):  # Метод класса - раннее связывание\n        cls.tax_rate = rate\n    \n    @staticmethod\n    def validate_amount(amount):  # Статический метод - раннее связывание\n        return amount > 0\n    \n    def calculate_total(self):  # Метод экземпляра - позднее связывание\n        return self.amount * (1 + self.tax_rate)\n\n# Демонстрация\nprint(PaymentSystem.validate_amount(100))  # True - статический метод\n\nPaymentSystem.set_tax_rate(0.25)  # Меняем атрибут класса\npayment = PaymentSystem(1000)\n\n# Динамическое связывание - метод определяется во время выполнения\nprint(payment.calculate_total())  # 1250.0\n\n# Можно даже динамически заменить метод!\ndef new_calculation(self):\n    return f\"Новый расчёт: {self.amount * (1 + PaymentSystem.tax_rate)}\"\n\npayment.calculate_total = new_calculation.__get__(payment)\nprint(payment.calculate_total())  # Новый расчёт: 1250.0\n```"
  popularity = 0.0

[[questions]]
  id = 7
  question = "Является – «is a», имеет – «has a»"
  answer = "{{< figure src=association.png >}}\n \n **Наследование** «is a» ЯВЛЯТЬСЯ (обобщение/расширение) – очень мощная связь\n\n  **Ассоциация** «has a» ИМЕТЬ (объекты ИМЕЮТ ссылки/ссылаются друг на друга)\n"
  popularity = 0.0
